# تمرین شماره 2 - الگوهای طراحی
## سیستم مدیریت درخواست‌های پشتیبانی (Ticketing System)

---

## بخش 1: تشخیص زیرمسائل و الگوها

### زیرمسئله 1: مدیریت وضعیت‌های تیکت

**شرح:**
در سیستم فعلی، وضعیت‌های تیکت (NEW, ASSIGNED, IN_PROGRESS, RESOLVED, CLOSED) با استفاده از زنجیره‌ای از if-else مدیریت می‌شوند. این رویکرد باعث می‌شود که:
- کد پیچیده و غیرقابل نگهداری شود
- افزودن وضعیت جدید نیاز به تغییر کد موجود داشته باشد
- منطق هر وضعیت در یک مکان متمرکز نباشد

**الگوی پیشنهادی:** State Pattern

**دلیل انتخاب:**
- الگوی State برای مدیریت رفتار وابسته به حالت مناسب است
- هر وضعیت می‌تواند رفتار خود را به صورت مستقل مدیریت کند
- افزودن وضعیت جدید بدون تغییر کد موجود امکان‌پذیر می‌شود
- از اصل Open/Closed Principle پیروی می‌کند

**روش اعمال:**
1. ایجاد رابط `TicketState` با متد `handle()`
2. ایجاد کلاس‌های مجزا برای هر وضعیت: `NewState`, `AssignedState`, `InProgressState`, `ResolvedState`, `ClosedState`
3. کلاس `Ticket` یک نمونه از `TicketState` را نگه می‌دارد
4. هر وضعیت، وضعیت بعدی را تنظیم می‌کند

---

### زیرمسئله 2: مدیریت کانال‌های ورودی

**شرح:**
سیستم باید از کانال‌های مختلفی مانند WEB و EMAIL درخواست دریافت کند. در کد فعلی، این با if-else مدیریت می‌شود که باعث می‌شود:
- افزودن کانال جدید نیاز به تغییر کد موجود داشته باشد
- منطق هر کانال در یک مکان متمرکز نباشد

**الگوی پیشنهادی:** Strategy Pattern

**دلیل انتخاب:**
- الگوی Strategy برای الگوریتم‌های قابل تعویض مناسب است
- هر کانال می‌تواند استراتژی خود را داشته باشد
- افزودن کانال جدید بدون تغییر کد موجود امکان‌پذیر می‌شود
- از اصل Open/Closed Principle پیروی می‌کند

**روش اعمال:**
1. ایجاد رابط `ChannelHandler` با متد `handleChannel()`
2. ایجاد کلاس‌های `WebChannelHandler` و `EmailChannelHandler`
3. استفاده از Factory برای انتخاب Handler مناسب

---

### زیرمسئله 3: مدیریت انواع درخواست

**شرح:**
سیستم باید انواع مختلف درخواست (مانند BUG و انواع دیگر) را مدیریت کند. در کد فعلی، این با if-else مدیریت می‌شود که باعث می‌شود:
- افزودن نوع جدید نیاز به تغییر کد موجود داشته باشد
- منطق هر نوع در یک مکان متمرکز نباشد

**الگوی پیشنهادی:** Strategy Pattern

**دلیل انتخاب:**
- الگوی Strategy برای الگوریتم‌های قابل تعویض مناسب است
- هر نوع درخواست می‌تواند استراتژی خود را برای ارجاع داشته باشد
- افزودن نوع جدید بدون تغییر کد موجود امکان‌پذیر می‌شود

**روش اعمال:**
1. ایجاد رابط `TypeHandler` با متد `assignTicket()`
2. ایجاد کلاس‌های `BugTypeHandler` و `GenericTypeHandler`
3. استفاده از Factory برای انتخاب Handler مناسب

---

### زیرمسئله 4: تولید و ارسال پاسخ

**شرح:**
سیستم باید بر اساس نوع درخواست، پاسخ مناسب تولید و ارسال کند. در کد فعلی، این با if-else مدیریت می‌شود.

**الگوی پیشنهادی:** Strategy Pattern

**دلیل انتخاب:**
- الگوی Strategy برای الگوریتم‌های قابل تعویض مناسب است
- هر نوع درخواست می‌تواند استراتژی خود را برای تولید پاسخ داشته باشد
- افزودن نوع پاسخ جدید بدون تغییر کد موجود امکان‌پذیر می‌شود

**روش اعمال:**
1. ایجاد رابط `ResponseHandler` با متد `sendResponse()`
2. ایجاد کلاس‌های `BugResponseHandler` و `GenericResponseHandler`
3. استفاده از Factory برای انتخاب Handler مناسب

---

### زیرمسئله 5: ایجاد تیکت با تنظیمات مناسب

**شرح:**
ایجاد تیکت نیاز به اعتبارسنجی و تنظیمات اولیه دارد. در کد فعلی، این به صورت مستقیم انجام می‌شود.

**الگوی پیشنهادی:** Factory Pattern

**دلیل انتخاب:**
- الگوی Factory برای ایجاد آبجکت‌های پیچیده مناسب است
- می‌تواند اعتبارسنجی و تنظیمات اولیه را مدیریت کند
- امکان ایجاد انواع مختلف تیکت با پارامترهای مختلف را فراهم می‌کند
- منطق ایجاد را از کلاینت جدا می‌کند

**روش اعمال:**
1. ایجاد کلاس `TicketFactory` با متد استاتیک `createTicket()`
2. اعتبارسنجی ورودی‌ها در Factory
3. ایجاد و تنظیم تیکت با وضعیت اولیه مناسب

---

## بخش 2: Class Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                         TicketService                            │
├─────────────────────────────────────────────────────────────────┤
│ + handle(ticket: Ticket): void                                  │
└───────────────────────────┬─────────────────────────────────────┘
                            │
                            │ uses
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│                            Ticket                                │
├─────────────────────────────────────────────────────────────────┤
│ - id: int                                                       │
│ - state: TicketState                                            │
│ - channel: String                                               │
│ - type: String                                                  │
│ - request: String                                               │
│ - response: String                                              │
├─────────────────────────────────────────────────────────────────┤
│ + getStatus(): String                                           │
│ + setState(state: TicketState): void                           │
│ + getState(): TicketState                                       │
└───────────────────────────┬─────────────────────────────────────┘
                            │
                            │ has
                            ▼
                    ┌───────────────┐
                    │ TicketState   │ ◄───────┐
                    ├───────────────┤         │
                    │ + handle()    │         │
                    │ + getStatus() │         │
                    └───────┬───────┘         │
                            │                │
                            │ implements     │
            ┌───────────────┼───────────────┼───────────────┐
            │               │               │               │
    ┌───────▼───────┐ ┌─────▼──────┐ ┌─────▼──────┐ ┌─────▼──────┐
    │   NewState    │ │ AssignedState│ │InProgressState│ │ResolvedState│
    └───────┬───────┘ └─────┬──────┘ └─────┬──────┘ └─────┬──────┘
            │               │               │               │
            │               │               │               │
    ┌───────▼───────────────▼───────────────▼───────────────▼───────┐
    │                        ClosedState                             │
    └───────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                      ChannelHandler (Strategy)                   │
├─────────────────────────────────────────────────────────────────┤
│ + handleChannel(ticket: Ticket): void                           │
└───────────────┬─────────────────────────────────────────────────┘
                │
                │ implements
    ┌───────────┼───────────┐
    │           │           │
┌───▼────┐ ┌────▼─────┐ ┌──▼──────────┐
│ Web    │ │ Email    │ │ Channel     │
│ Handler│ │ Handler  │ │ Handler     │
│        │ │          │ │ Factory     │
└────────┘ └──────────┘ └─────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                       TypeHandler (Strategy)                     │
├─────────────────────────────────────────────────────────────────┤
│ + assignTicket(ticket: Ticket): void                            │
└───────────────┬─────────────────────────────────────────────────┘
                │
                │ implements
    ┌───────────┼───────────┐
    │           │           │
┌───▼────┐ ┌────▼─────┐ ┌──▼──────────┐
│ Bug    │ │ Generic  │ │ Type        │
│ Handler│ │ Handler  │ │ Handler     │
│        │ │          │ │ Factory     │
└────────┘ └──────────┘ └─────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                     ResponseHandler (Strategy)                   │
├─────────────────────────────────────────────────────────────────┤
│ + sendResponse(ticket: Ticket): void                            │
└───────────────┬─────────────────────────────────────────────────┘
                │
                │ implements
    ┌───────────┼───────────┐
    │           │           │
┌───▼────┐ ┌────▼─────┐ ┌──▼──────────────┐
│ Bug    │ │ Generic  │ │ Response        │
│ Response│ │ Response │ │ Handler        │
│ Handler │ │ Handler  │ │ Factory        │
└────────┘ └──────────┘ └─────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                      TicketFactory (Factory)                    │
├─────────────────────────────────────────────────────────────────┤
│ + createTicket(id: int, channel: String, type: String): Ticket  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                            Logger                                │
├─────────────────────────────────────────────────────────────────┤
│ + log(ticket: Ticket): void                                     │
└─────────────────────────────────────────────────────────────────┘
```

---

## بخش 3: اعمال الگوها

تمام الگوهای پیشنهادی در بخش 1 اعمال شده‌اند:

### 1. State Pattern
- رابط `TicketState` ایجاد شد
- کلاس‌های `NewState`, `AssignedState`, `InProgressState`, `ResolvedState`, `ClosedState` پیاده‌سازی شدند
- کلاس `Ticket` از `TicketState` استفاده می‌کند
- کلاس `TicketService` به سادگی `handle()` وضعیت فعلی را فراخوانی می‌کند

### 2. Strategy Pattern برای کانال‌ها
- رابط `ChannelHandler` ایجاد شد
- کلاس‌های `WebChannelHandler` و `EmailChannelHandler` پیاده‌سازی شدند
- `ChannelHandlerFactory` برای انتخاب Handler مناسب استفاده می‌شود

### 3. Strategy Pattern برای انواع درخواست
- رابط `TypeHandler` ایجاد شد
- کلاس‌های `BugTypeHandler` و `GenericTypeHandler` پیاده‌سازی شدند
- `TypeHandlerFactory` برای انتخاب Handler مناسب استفاده می‌شود

### 4. Strategy Pattern برای پاسخ‌ها
- رابط `ResponseHandler` ایجاد شد
- کلاس‌های `BugResponseHandler` و `GenericResponseHandler` پیاده‌سازی شدند
- `ResponseHandlerFactory` برای انتخاب Handler مناسب استفاده می‌شود

### 5. Factory Pattern
- کلاس `TicketFactory` با متد `createTicket()` ایجاد شد
- اعتبارسنجی ورودی‌ها در Factory انجام می‌شود
- کلاس `Main` از Factory برای ایجاد تیکت استفاده می‌کند

---

## بخش 4: تحلیل شی‌گرا (SOLID + PLK + CRP)

### مقایسه قبل و بعد از اعمال الگوها:

#### 1. Single Responsibility Principle (SRP)
**قبل:** کلاس `TicketService` مسئولیت‌های متعددی داشت: مدیریت وضعیت‌ها، مدیریت کانال‌ها، مدیریت انواع درخواست، تولید پاسخ، و ثبت لاگ.

**بعد:** 
- هر کلاس State مسئولیت مدیریت یک وضعیت را دارد
- هر Handler مسئولیت مدیریت یک استراتژی خاص را دارد
- `TicketService` فقط مسئولیت هماهنگی را دارد
- `Logger` مسئولیت ثبت لاگ را دارد

**بهبود:** هر کلاس یک مسئولیت واحد دارد و کد قابل نگهداری‌تر شده است.

---

#### 2. Open/Closed Principle (OCP)
**قبل:** برای افزودن وضعیت جدید، کانال جدید، یا نوع جدید، باید کد `TicketService` تغییر می‌کرد.

**بعد:**
- برای افزودن وضعیت جدید: فقط یک کلاس State جدید ایجاد می‌شود
- برای افزودن کانال جدید: فقط یک کلاس ChannelHandler جدید ایجاد می‌شود
- برای افزودن نوع جدید: فقط کلاس‌های TypeHandler و ResponseHandler جدید ایجاد می‌شوند

**بهبود:** سیستم برای گسترش باز است اما برای تغییر بسته است. کد موجود نیازی به تغییر ندارد.

---

#### 3. Liskov Substitution Principle (LSP)
**قبل:** این اصل در کد قبلی قابل اعمال نبود چون از وراثت استفاده نمی‌شد.

**بعد:**
- تمام کلاس‌های State می‌توانند جایگزین یکدیگر شوند
- تمام کلاس‌های Handler می‌توانند جایگزین یکدیگر شوند

**بهبود:** هر کلاس مشتق شده می‌تواند بدون تغییر رفتار برنامه جایگزین کلاس پایه شود.

---

#### 4. Interface Segregation Principle (ISP)
**قبل:** این اصل در کد قبلی قابل اعمال نبود چون از interface استفاده نمی‌شد.

**بعد:**
- هر interface فقط متدهای مورد نیاز را دارد
- `TicketState` فقط متدهای مربوط به وضعیت را دارد
- `ChannelHandler` فقط متد مدیریت کانال را دارد
- `TypeHandler` فقط متد ارجاع را دارد
- `ResponseHandler` فقط متد تولید پاسخ را دارد

**بهبود:** کلاس‌ها مجبور نیستند متدهایی را پیاده‌سازی کنند که استفاده نمی‌کنند.

---

#### 5. Dependency Inversion Principle (DIP)
**قبل:** کلاس‌های سطح بالا مستقیماً به کلاس‌های سطح پایین وابسته بودند.

**بعد:**
- `TicketService` به abstraction (`TicketState`) وابسته است نه به implementation
- کلاس‌های State به abstraction (`ChannelHandler`, `TypeHandler`, `ResponseHandler`) وابسته هستند
- Factory ها dependency injection را انجام می‌دهند

**بهبود:** وابستگی‌ها معکوس شده‌اند و کلاس‌های سطح بالا به abstraction وابسته هستند.

---

#### 6. Package Level Knowledge (PLK)
**قبل:** تمام منطق در یک کلاس بود و هیچ ساختار بسته‌بندی وجود نداشت.

**بعد:**
- بسته‌بندی منطقی: `state`, `channel`, `type`, `response`, `factory`, `logger`
- هر بسته فقط کلاس‌های مرتبط را دارد
- وابستگی‌ها بین بسته‌ها به حداقل رسیده است

**بهبود:** ساختار بسته‌بندی واضح و منطقی است و هر بسته دانش محدودی از بسته‌های دیگر دارد.

---

#### 7. Common Reuse Principle (CRP)
**قبل:** تمام کد در یک مکان بود و امکان استفاده مجدد وجود نداشت.

**بعد:**
- کلاس‌های Handler قابل استفاده مجدد هستند
- کلاس‌های State قابل استفاده مجدد هستند
- Factory قابل استفاده مجدد است

**بهبود:** کلاس‌هایی که با هم استفاده می‌شوند در یک بسته قرار دارند و امکان استفاده مجدد افزایش یافته است.

---

## نتیجه‌گیری

پس از اعمال الگوهای طراحی:
- **قابلیت نگهداری:** کد بسیار قابل نگهداری‌تر شده است
- **قابلیت گسترش:** افزودن ویژگی‌های جدید بدون تغییر کد موجود امکان‌پذیر است
- **قابلیت تست:** هر کلاس به صورت مستقل قابل تست است
- **خوانایی:** ساختار کد واضح‌تر و قابل فهم‌تر شده است
- **انعطاف‌پذیری:** سیستم انعطاف‌پذیرتر شده و می‌تواند به راحتی تغییر کند

تمام اصول SOLID + PLK + CRP رعایت شده‌اند و سیستم از نظر طراحی شی‌گرا بهبود قابل توجهی یافته است.
